<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="revealjs/css/reveal.min.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/assets/css/bundle.css"/>
  <link rel="stylesheet" href="/assets/css/theme.css"/>

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'revealjs/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="revealjs/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">
<section id="painting-in-clojure" class="slide level1">
<h1>Painting in Clojure</h1>
<div style="font-size:2em">
by <span class="citation" data-cites="tombooth">@tombooth</span>
</div>
<aside class="notes">
<ul>
<li>Picked up as an early 'learn clojure' project</li>
<li>Not a web project</li>
<li>Not just programming, reminded me of some basic physics</li>
</ul>
</aside>
</section>
<section id="jackson-pollock" class="slide level1">
<h1>Jackson Pollock</h1>
<figure>
<img src="img/number-8.jpg" alt="Jackson Pollock: Number 8" /><figcaption>Jackson Pollock: Number 8</figcaption>
</figure>
<aside class="notes">
<ul>
<li>Famous 20th century abstract painter</li>
<li>Made 'drip painting' famous, a form of action paiting</li>
<li>Drips paints off brushes, sticks or bits of wood onto the cavnas</li>
<li>We are going to start our model by considering a single point of paint, rather than a path</li>
</ul>
</aside>
</section>
<section id="defining-our-space---i" class="slide level1">
<h1>Defining our space - I</h1>
<figure>
<img src="img/facts.jpg" />
</figure>
<aside class="notes">
<ul>
<li>We need a space to work in and some basic physical details</li>
</ul>
</aside>
</section>
<section id="defining-our-space---ii" class="slide level1">
<h1>Defining our space - II</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> space </span>[<span class="dv">8</span>   <span class="co">;; width</span>
            <span class="dv">5</span>   <span class="co">;; height</span>
            <span class="dv">6</span>]) <span class="co">;; depth</span>

(<span class="kw">def</span><span class="fu"> gravity </span>[<span class="dv">0</span> -<span class="fl">9.8</span> <span class="dv">0</span>])

(<span class="kw">def</span><span class="fu"> canvas-normal </span>[<span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span>])</code></pre>
<aside class="notes">
<ul>
<li>Facts defined using def and given a name</li>
<li>These are composed of basic clojure types</li>
<li>All our measurements are in SI units with pixel conversion in drawing</li>
</ul>
</aside>
</section>
<section id="picking-a-starting-point" class="slide level1">
<h1>Picking a starting point</h1>
<p>A gesture has to start somewhere inside of our defined space.</p>
<figure>
<img src="img/starting-point.jpg" />
</figure>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> starting-point </span>[]
  (<span class="kw">map</span> <span class="kw">rand</span> space))</code></pre>
<aside class="notes">
<ul>
<li>A gesture has to start somewhere</li>
<li>A very expressive set of characters</li>
</ul>
</aside>
</section>
<section id="projection---i" class="slide level1">
<h1>Projection - I</h1>
<figure>
<img src="img/projection.jpg" />
</figure>
<aside class="notes">
<ul>
<li>Our point needs to hit the canvas</li>
<li>Using basic equations of motion</li>
<li>We know the the canvas is at y = 0</li>
<li>We need ot find time to impact in order to find other values</li>
</ul>
</aside>
</section>
<section id="projection---ii" class="slide level1">
<h1>Projection - II</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> time-to-canvas </span>[position velocity acceleration]
  (<span class="kw">let</span> [a acceleration
        b (<span class="kw">*</span> <span class="dv">2</span> velocity)
        c (<span class="kw">*</span> <span class="dv">2</span> position)
        discriminant (<span class="kw">-</span> (<span class="kw">*</span> b b) (<span class="kw">*</span> <span class="dv">4</span> a c))
        minus-b (<span class="kw">-</span> <span class="dv">0</span> b)
        add-sqrt (<span class="kw">/</span> (<span class="kw">+</span> minus-b (Math/sqrt discriminant)) (<span class="kw">*</span> <span class="dv">2</span> a))
        minus-sqrt (<span class="kw">/</span> (<span class="kw">-</span> minus-b (Math/sqrt discriminant)) (<span class="kw">*</span> <span class="dv">2</span> a))]
    (<span class="kw">max</span> add-sqrt minus-sqrt)))</code></pre>
<aside class="notes">
<ul>
<li>Solved nicely using Quadratic Equation</li>
<li>One value will be negative so always pick the max</li>
</ul>
</aside>
</section>
<section id="projection---iii" class="slide level1">
<h1>Projection - III</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> position-at </span>[<span class="kw">time</span> initial-position initial-velocity acceleration]
  (<span class="kw">+</span> initial-position
     (<span class="kw">*</span> initial-velocity <span class="kw">time</span>)
     (<span class="kw">/</span> (<span class="kw">*</span> acceleration <span class="kw">time</span> <span class="kw">time</span>) <span class="dv">2</span>)))

(<span class="kw">defn</span><span class="fu"> velocity-at </span>[<span class="kw">time</span> initial-velocity acceleration]
  (<span class="kw">+</span> (<span class="kw">*</span> acceleration <span class="kw">time</span>) initial-velocity))

(<span class="kw">defn</span><span class="fu"> project-point </span>[position velocity]
  (<span class="kw">let</span> [[i j k]            position
        [vi vj vk]         velocity
        [ai aj ak]         gravity
        <span class="kw">time</span>               (time-to-canvas j vj aj)
        projected-position [(position-at <span class="kw">time</span> i vi ai)
                            <span class="dv">0</span>
                            (position-at <span class="kw">time</span> k vk ak)]
        projected-velocity [(velocity-at <span class="kw">time</span> vi ai)
                            (velocity-at <span class="kw">time</span> vj aj)
                            (velocity-at <span class="kw">time</span> vk ak)]]
    [projected-position
     projected-velocity]))</code></pre>
<aside class="notes">
<ul>
<li>Now we have time to impact it is easy to derive everything else</li>
<li>For the position we can use the same function as we derieved the time with:
<ul>
<li><span class="math">$r = r0 + v0 * t + \frac{at^2}{2}$</span></li>
</ul></li>
<li><p>For velocity we can use: <span class="math"><em>v</em> = <em>a</em><em>t</em> + <em>v</em>0</span></p></li>
<li>An important aspect of Pollock's paintings is the splatter made as he flicks paint against the canvas, we are now going to look at how to work out whether this impact should splatter</li>
</ul>
</aside>
</section>
<section id="splatter---i" class="slide level1">
<h1>Splatter - I</h1>
<figure>
<img src="img/impact.jpg" />
</figure>
<aside class="notes">
<ul>
<li>We need to work out whether an impact should splatter
<ul>
<li>look at the impact force</li>
<li>Impact force derived from work-energy principle:
<ul>
<li>W=E_k=12mv_2<sup>2-12mv_1</sup>2,</li>
</ul></li>
</ul></li>
<li>We need to define a cutoff for this</li>
<li>If it does splatter we need to bounce the vector</li>
<li>Collision is inelastic so it should absorb some of the vector
<ul>
<li>inelastic means conservation of energy is not maintained and energy is lost through various means</li>
</ul></li>
</ul>
</aside>
</section>
<section id="splatter---ii" class="slide level1">
<h1>Splatter - II</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; B = V - (2 * (V.N) * N)</span>

(<span class="kw">defn</span><span class="fu"> dot-product </span>[vector1 vector2]
  (<span class="kw">reduce</span> <span class="kw">+</span> (<span class="kw">map</span> <span class="kw">*</span> vector1 vector2)))

(<span class="kw">defn</span><span class="fu"> vector-subtraction </span>[vector1 vector2]
  (<span class="kw">map</span> <span class="kw">-</span> vector1 vector2))

(<span class="kw">defn</span><span class="fu"> vector-multiply-by-constant </span>[<span class="kw">vector</span> constant]
  (<span class="kw">map</span> #(<span class="kw">*</span> % constant) <span class="kw">vector</span>))

(<span class="kw">defn</span><span class="fu"> bounce-vector </span>[<span class="kw">vector</span> normal]
  (<span class="kw">let</span> [vector-dot-normal (dot-product <span class="kw">vector</span> normal)
        extreme (vector-multiply-by-constant normal (<span class="kw">*</span> <span class="dv">2</span> vector-dot-normal))]
    (vector-subtraction <span class="kw">vector</span> extreme)))</code></pre>
<aside class="notes">
<p>The equation to bounce a vector, <span class="math"><em>V</em></span>, off a plane with normal, <span class="math"><em>N</em></span>, is:</p>
<ul>
<li><span class="math"><em>N</em></span> is the normal vector of the plane</li>
<li><span class="math"><em>V</em></span> = the incoming vector</li>
<li><span class="math"><em>B</em></span> is the outgoing, bounced, vector</li>
</ul>
<span class="math"><em>B</em> = <em>V</em> − (2 * (<em>V</em>.<em>N</em>) * <em>N</em>)</span>
</aside>
</section>
<section id="paths---i" class="slide level1">
<h1>Paths - I</h1>
<figure>
<img src="img/bezier.jpg" />
</figure>
<aside class="notes">
<ul>
<li>Parametric curves used in vector graphics because they scale indefinitely</li>
<li>Gives nice smooth curves</li>
<li>We need anchor, or control, points to calculate a bezier curve</li>
<li>Do a random walk in a random direction to define these</li>
</ul>
</aside>
</section>
<section id="paths---ii" class="slide level1">
<h1>Paths - II</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> random-path </span>[position step-vector bounds]
  (<span class="kw">cons</span> position
        (<span class="kw">lazy-seq</span> (random-path (vector-add (vector-add position step-vector)
                                           (random-vector-between (<span class="kw">-</span> <span class="dv">0</span> bounds) bounds))
                               step-vector bounds))))

(<span class="kw">defn</span><span class="fu"> anchor-points </span>[position min-distance max-distance min-steps max-steps variation]
  (<span class="kw">let</span> [direction        (random-unit-vector)
        distance         (random-between min-distance max-distance)
        steps            (random-between min-steps max-steps)
        step-vector      (vector-multiply-by-constant direction (<span class="kw">/</span> distance steps))
        random-positions (<span class="kw">take</span> steps (random-path position step-vector variation))
        end-position     (vector-add position
                                     (vector-multiply-by-constant step-vector steps))]
    (<span class="kw">conj</span> (<span class="kw">vec</span> random-positions) end-position)))</code></pre>
<aside class="notes">
<ul>
<li>Lazy seqs, they are aces</li>
<li>Random total distance and number of steps</li>
<li>These are then used to work out the anchor points</li>
<li>A known end point is used</li>
</ul>
</aside>
</section>
<section id="paths---iii" class="slide level1">
<h1>Paths - III</h1>
<figure>
<img src="img/de-casteljau.jpg" />
</figure>
<aside class="notes">
<ul>
<li>De casteljau is a recursive method for evaluating Bezier curves</li>
<li>Finding a point between two points (along a line)</li>
<li>De casteljau is just that on mainly lines in parallel</li>
</ul>
</aside>
</section>
<section id="paths---iv" class="slide level1">
<h1>Paths - IV</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> recur-relation </span>[t a b]
  (<span class="kw">+</span> (<span class="kw">*</span> t b) (<span class="kw">*</span> a (<span class="kw">-</span> <span class="dv">1</span> t))))

(<span class="kw">defn</span><span class="fu"> for-component </span>[t component-vals]
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">count</span> component-vals) <span class="dv">1</span>)
    (<span class="kw">first</span> component-vals)
    (for-component t
      (<span class="kw">map</span> #(recur-relation t %<span class="dv">1</span> %<span class="dv">2</span>) component-vals (<span class="kw">rest</span> component-vals)))))

(<span class="kw">defn</span><span class="fu"> for-t </span>[t components]
  (<span class="kw">map</span> #(for-component t %) components))

(<span class="kw">defn</span><span class="fu"> de-casteljau </span>[control-points step-amount]
  (<span class="kw">let</span> [x-vals (<span class="kw">map</span> <span class="kw">first</span> control-points)
        y-vals (<span class="kw">map</span> <span class="kw">second</span> control-points)
        z-vals (<span class="kw">map</span> #(<span class="kw">nth</span> % <span class="dv">2</span>) control-points)
        points (<span class="kw">map</span> #(for-t % [x-vals y-vals z-vals]) (<span class="kw">range</span> <span class="dv">0</span> <span class="dv">1</span> step-amount))]
    points))</code></pre>
<aside class="notes">
<ul>
<li>Considers each dimension on its own</li>
<li>recur-relation is the weighted point calc</li>
</ul>
</aside>
</section>
<section id="a-sense-of-motion---i" class="slide level1">
<h1>A sense of motion - I</h1>
<figure>
<img src="img/motion.jpg" />
</figure>
<aside class="notes">
<ul>
<li>Linear model for paint volume and velocity</li>
<li>Sectors of path won't be even so need to consider velocity in sector</li>
</ul>
</aside>
</section>
<section id="a-sense-of-motion---ii" class="slide level1">
<h1>A sense of motion - II</h1>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> velocity-between </span>[point1 point2 total-time total-distance]
  (<span class="kw">let</span> [difference-vector (vector-subtraction point1 point2)
        time-between (<span class="kw">*</span> total-time (<span class="kw">/</span> (distance-between-points point1 point2)
                                      total-distance))]
    (vector-divide-by-const difference-vector time-between)))

(<span class="kw">defn</span><span class="fu"> path-velocities </span>[<span class="kw">path</span> total-time]
  (<span class="kw">let</span> [total-distance   (path-length <span class="kw">path</span>)
        number-of-points (<span class="kw">count</span> <span class="kw">path</span>)]
    (<span class="kw">conj</span> (<span class="kw">vec</span> (map<span class="dv">-2</span> #(velocity-between %<span class="dv">1</span> %<span class="dv">2</span>
                                         total-time
                                         total-distance)
                      <span class="kw">path</span>))
          [<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>])))

(<span class="kw">defn</span><span class="fu"> path-masses </span>[<span class="kw">path</span> initial-mass]
  (<span class="kw">let</span> [number-of-points (<span class="kw">count</span> <span class="kw">path</span>)
        step (<span class="kw">-</span> <span class="dv">0</span> (<span class="kw">/</span> initial-mass number-of-points))]
    (<span class="kw">take</span> number-of-points (<span class="kw">range</span> initial-mass <span class="dv">0</span> step))))</code></pre>
<aside class="notes">
<ul>
<li>map-2 runs over pairs of numbers</li>
</ul>
</aside>
</section>
<section id="pull-it-all-together" class="slide level1">
<h1>Pull it all together</h1>
<canvas id="pollock" style="width:80%"></canvas>
<br/>
<button id="add">
Add a stroke
</button>
<button id="fill">
Fill canvas
</button>



</section>
    </div>
  </div>
  <script src="revealjs/lib/js/head.min.js"></script>
  <script src="revealjs/js/reveal.min.js"></script>
  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        //center: true,
        transition: 'none',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'revealjs/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'revealjs/plugin/math/math.js', async: true }
        ]});
    </script>
    <script src="../js/processing-1.4.8.js"></script>
    <script src="../js/main.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-37313472-4', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
