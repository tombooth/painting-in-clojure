
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1">
    <title>Painting in Clojure - Tom Booth</title>
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="/assets/css/bundle.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="/assets/css/theme.css" type="text/css" media="screen" charset="utf-8">
  </head>
  <body>
    <header>
      <h1>Painting in Clojure<small>by <a href="/">Tom Booth</a></small></h1>
    </header>
    <main>
<p>Learning Clojure by building a digital Jackson Pollock. This article and the source code backing it can be <a href="https://www.github.com/tombooth/painting-in-clojure">found on GitHub</a>. Below is an example of what we will be building, running the code found in this page.</p>
<canvas id="pollock" style="width: 100%; border: 5px solid #eee"></canvas>
<button id="add">
Add stroke
</button>
<button id="fill">
Fill canvas
</button>



<h2 id="jackson-pollock">Jackson Pollock</h2>
<p>He was an abstract artist who lived through the first half of the 20th century and is most famous for his drip paintings. This style of painting involves him using sticks brushes, sticks and cans to apply paint to the canvas with the motion of his gestures causing the artworks to come alive. You can get a good idea of how this comes together from <a href="https://www.youtube.com/watch?v=7bICqvmKL5s">this youtube video</a>.</p>
<h2 id="setting-the-scene">Setting the scene</h2>
<p>We want to define some facts about the space that our digital Pollock will work in. These facts will not change over the execution of our model and fit Clojure's preference for immutability perfectly. For those who have not come across the idea of mutability before it is simply whether something can be changed in place. In most languages if you set the label <code>some_number</code> to equal <code>5</code>, further on you can increment the value of <code>some_number</code> to <code>6</code> or even <code>7</code>. In Clojure if you tried to increment <code>some_number</code> you would get a new value rather than changing <code>some_number</code>.</p>
<p>Clojure will let us define facts using one of the following value types:</p>
<ul>
<li>A number. This could be <code>5</code> an integer, <code>3/2</code> a ratio/fraction or <code>3.14</code> a floating point number;</li>
<li>A string, represented as a sequence of characters, for example <code>&quot;Hello world!&quot;</code>;</li>
<li>A keyword, which are very similar to strings in appearance except they are preceded by a colon e.g. <code>:an-identifier</code>. As alluded to in the example they are usually used for identifiers or labels and do not allow spaces.</li>
<li>A list <code>(...)</code>, this is a way of grouping values into a collection with an explicit order. You may notice all of the code written takes for form of lists. By default if you have written <code>(...)</code> Clojure will assume the first item is a function and the rest are arguments to be passed in. In order for the list not to be executed you should prefix it with a <code>'</code>;</li>
<li>A vector <code>[...]</code>, which is a lot like a list except that they are optimised for appending to the end of the sequence rather than to the front;</li>
<li>A set <code>#{...}</code>. If you are not particularly bothered by the order of the values stored in your collection then you can use a set;</li>
<li>Lastly there are maps <code>{...}</code>, these store pairs of values where the first is a key and the second is a value.</li>
</ul>
<p>If you would like to learn more about the basic types in Clojure, I suggest you read <a href="http://aphyr.com/posts/302-clojure-from-the-ground-up-basic-types">this great blog post</a> by Aphyr.</p>
<p>The most important fact about the space is its size. We will use metres to measure the size only converting to pixels when we need to draw to the screen. We are going to define size as a vector containing its width, height and depth.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> space </span>[<span class="dv">8</span>   <span class="co">;; width</span>
            <span class="dv">5</span>   <span class="co">;; height</span>
            <span class="dv">6</span>]) <span class="co">;; depth</span></code></pre>
<p>We need to know the gravity of the space so it can influence the flow of paint as it leaves the brush. This will be defined as a vector that represents acceleration influenced by gravity.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> gravity </span>[<span class="dv">0</span> -<span class="fl">9.8</span> <span class="dv">0</span>])</code></pre>
<p>Lastly, we need to know the normal of the surface of the canvas that the paint will impact with. This will be used to dictate how paint acts when it spatters from the impact with the canvas.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> canvas-normal </span>[<span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span>])





</code></pre>
<h2 id="starting-points-and-projection">Starting points and projection</h2>
<p>Our digital Pollock is going to start a stroke of the brush by picking a random point in space. This point will then be projected to find where it impacts with the canvas.</p>
<p>In order to generate a random point inside of the space we need to define a function that each time it is called will emit a vector containing the position of the point. Function values can be created by calling <code>(fn [...] ...)</code> with the first vector being the arguments the function should receive and any follow items in the list are the body of the function and executed with the arguments bound. Rather than calling <code>(def name (fn ...))</code> Clojure has provided a shortcut function <code>(defn name [...] ...)</code>. An example of a defined function is <code>(defn say-hello [name] (str &quot;Hello &quot; name))</code>, this creates a function called say-hello that when called <code>(say-hello &quot;James&quot;)</code> it will return the string &quot;Hello James&quot;.</p>
<p>We are going to cover a common functional idiom when dealing with lists to change the dimensions of the space above into a random point inside that space. To do this we want to iterate over each dimension of the size of space, generate a random number between 0 and the magnitude of each dimension and then return the resultant list of random numbers as a list. To generate a random number in Clojure we can use the <code>(rand)</code> function, which will return a random number between 0 (inclusive) and 1 (exclusive). The rand function can take an optional parameter `(rand 100), this will define the bounds of the number generated to 0 and 100.</p>
<p>The function map <code>(map [fn] [sequence])</code> will iterate through the sequence executing the function with the current value of the sequence as its first parameter, the values returned from the function will be stored in a list the same length as the sequence and returned by the function.</p>
<p>We can now define a random point inside of space as follows</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> starting-point </span>[] (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/rand" target="_blank" class="kw">rand</a> space))
</code></pre>
<p>Now that we can generate a random point in space we want to project this to the canvas. We are going to use <a href="https://en.wikipedia.org/wiki/Equations_of_motion">Newtonian equations of motion</a>, we know the position, velocity and acceleration of the point and we want to know what the position and velocity are when y is 0. In order to work out final positions we need to know the total time the point spent falling, we can do this using the y position as we know that the final position should be 0.</p>
<p>To work out the time it takes for the point to reach the canvas we will solve the following equation for t:</p>
<ul>
<li><span class="math">\(r\)</span> = final displacement,</li>
<li><span class="math">\(r_{0}\)</span> = initial displacement,</li>
<li><span class="math">\(v_{0}\)</span> = initial velocity,</li>
<li><span class="math">\(a\)</span> = acceleration,</li>
<li><span class="math">\(t\)</span> = time.</li>
</ul>
<p><span class="math">\(r = r_{0} + v_{0} * t + \frac{at^2}{2}\)</span></p>
<p>This rearranges to:</p>
<p><span class="math">\(at^2 + 2v_{0}t + 2r_{0} - 2r = 0\)</span></p>
<p>We can solve this using the Quadratic Equation, but this will yield us two results. In general we can say that we are interested in the result with the maximum value.</p>
<p>In the next block of code you can see an example of call out to Java(Script). Clojure doesn't have an in-built square root function, so we are calling out to the Java(Script) version. A function named in the form <code>foo/bar</code> means it will call the function <code>bar</code> in the namespace <code>foo</code>. You might be wondering, what is a namespace?.</p>
<p>All good languages need a way to bundle up code that is related, so that it can be reused and accessed only when needed. Clojure's take on this is to provide namespaces. Every Clojure source file will declare its namespace at the top of the file so that other files can reference it, extract values and use functions. Given that Clojure is a hosted language its namespace will related to packages in Java and Google Closure Library namespaces in Javascript.</p>
<p>When hosted on Java all of java.util.* is automatically imported and on JavaScript assorted core and Google Closure Library modules are imported. Both of these languages provide us with a Math namespace which contains a <code>sqrt</code> function.</p>
<p>If you want to learn more about Clojure -&gt; Java(Script) interop then have a read <a href="http://clojure-doc.org/articles/language/interop.html">of this article</a>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> time-to-canvas </span>[position velocity acceleration]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [a acceleration
        b (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> velocity)
        c (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> position)
        discriminant (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> b b) (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">4</span> a c))
        minus-b (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> <span class="dv">0</span> b)
        add-sqrt (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> minus-b (Math/sqrt discriminant)) (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> a))
        minus-sqrt (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> minus-b (Math/sqrt discriminant)) (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> a))]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/max" target="_blank" class="kw">max</a> add-sqrt minus-sqrt)))</code></pre>
<p>We can now calculate the time to impact but we want the final position and velocity. For position we can use the same function that we rearranged above to derive the time.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> position-at </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> initial-position initial-velocity acceleration]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> initial-position
     (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> initial-velocity <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a>)
     (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> acceleration <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a>) <span class="dv">2</span>)))</code></pre>
<p>For velocity we can use another equation of motion:</p>
<p><span class="math">\(v = at + v_{0}\)</span></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> velocity-at </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> initial-velocity acceleration]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> acceleration <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a>) initial-velocity))
</code></pre>
<p>These functions we just implemented can be joined up so that, given an initial position and velocity we can return the final position and velocity. This function doesn't explicitly ask for the acceleration acting on the paint, it assumes only gravity is acting using the constant defined earlier on.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> project-point </span>[position velocity]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [[i j k]            position
        [vi vj vk]         velocity
        [ai aj ak]         gravity
        
        <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a>               (time-to-canvas j vj aj)
        
        projected-position [(position-at <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> i vi ai)
                            <span class="dv">0</span>  <span class="co">;; we don&#39;t need to calculate as it</span>
                               <span class="co">;; should be 0, on the canvas</span>
                            (position-at <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> k vk ak)]
        
        projected-velocity [(velocity-at <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> vi ai)
                            (velocity-at <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> vj aj)
                            (velocity-at <a href="http://clojuredocs.org/clojure_core/clojure.core/time" target="_blank" class="kw">time</a> vk ak)]]
    [projected-position
     projected-velocity]))





</code></pre>
<h2 id="paint-splatter">Paint splatter</h2>
<p>An important aspect of Pollocks painting is the splatter of the paint hitting the canvas and what this adds to the images. We are going to add a simple splatter model based of the velocity at impact we calculated in the last part.</p>
<p>Not all paint that hits the canvas will splatter, so we need to work out the impact force of the paint and use this as a cutoff for whether the paint should splatter.</p>
<p>We will work out the impact force of the paint by taking the velocity at impact and calculating the force required to reduce that velocity to 0 over a set impact distance.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> impact-distance </span><span class="fl">0.05</span>)</code></pre>
<p>We can now use the work-energy principle (https://en.wikipedia.org/wiki/Work_(physics)#Work_and_energy) to calculate the impact force. On one side of the equation we will have the forces at play and the other the energy:</p>
<ul>
<li><span class="math">\(F_{i}\)</span> = impact force,</li>
<li>d = impact distance,</li>
<li>m = mass,</li>
<li>g = gravity,</li>
<li>v = velocity at impact.</li>
</ul>
<p><span class="math">\(-F_{i}d + mgd = 0 - \frac{1}{2}mv^2\)</span></p>
<p>This equation can be rearranged to:</p>
<p><span class="math">\(F_{i} = mg + \frac{mv^2}{2d}\)</span></p>
<p>For simplicity of code we are just going to consider the y axis as this is the most important when it comes to working out the impact force of the paint into the canvas. The above equation can therefore be expressed as:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> impact-force </span>[mass velocity]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [y-gravity (<a href="http://clojuredocs.org/clojure_core/clojure.core/second" target="_blank" class="kw">second</a> gravity)
        y-velocity (<a href="http://clojuredocs.org/clojure_core/clojure.core/second" target="_blank" class="kw">second</a> velocity)]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> mass y-gravity) (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> mass y-velocity y-velocity)
                             (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> impact-distance)))))</code></pre>
<p>Based of this function to calculate the impact force we can define a predicate that will tell us whether paint should splatter based off its mass and velocity. It is idiomatic in Clojure to end predicates with a <code>?</code>. We are going to add some randomness to this function so that we don't necessarily just get a uniform line of points. Also defined is a minimum force for us to consider whether some paint could splatter.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> min-impact-force-for-splatter </span><span class="dv">30</span>)

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> does-impact-splatter</span>? [mass velocity]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/and" target="_blank" class="kw">and</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/&gt;" target="_blank" class="kw">&gt;</a> (impact-force mass velocity) min-impact-force-for-splatter)
       (<a href="http://clojuredocs.org/clojure_core/clojure.core/&gt;" target="_blank" class="kw">&gt;</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/rand" target="_blank" class="kw">rand</a>) <span class="fl">0.8</span>)))</code></pre>
<p>If an impact splatters then we will need to bounce its velocity vector as this is the direction it will leave its current position.</p>
<p>The equation to bounce a vector, <span class="math">\(V\)</span>, off a plane with normal, <span class="math">\(N\)</span>, is:</p>
<ul>
<li><span class="math">\(N\)</span> is the normal vector of the plane</li>
<li><span class="math">\(V\)</span> = the incoming vector</li>
<li><span class="math">\(B\)</span> is the outgoing, bounced, vector</li>
</ul>
<p><span class="math">\(B = V - (2 * (V.N) * N)\)</span></p>
<p>You can find out a bit more about the derivation on this <a href="http://mathworld.wolfram.com/Reflection.html">Wolfram page</a>.</p>
<p>We are missing a few of the required vector operations used in this equation so we should define some more functions before trying to implement it. The first is the vector dot product, this is defined as the sum of the multiples of each dimension. Otherwise we need subtraction of two vectors and a function to multiply a vector by a constant.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> dot-product </span>[vector1 vector2]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/reduce" target="_blank" class="kw">reduce</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> vector1 vector2)))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> vector-subtraction </span>[vector1 vector2]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> vector1 vector2))</code></pre>
<p>This function will introduce a shorthand for defining functions that is very useful in combination with functions like <code>map</code> and <code>reduce</code>. Rather than writing <code>(fn [args...] body)</code> you can use <code>#(body)</code> and if you want access to the arguments use <code>%n</code> where <code>n</code> is the position of the argument. If you are only expecting one argument then you can use just <code>%</code> on its own.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> vector-multiply-by-constant </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a> constant]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> % constant) <a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a>))
</code></pre>
<p>Using the above functions we can now implement the vector bouncing equation. I have pulled <span class="math">\((2 * (V.N) * N)\)</span> out into a variable called extreme for clarity.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> bounce-vector </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a> normal]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [vector-dot-normal (dot-product <a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a> normal)
        extreme (vector-multiply-by-constant normal (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">2</span> vector-dot-normal))]
    (vector-subtraction <a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a> extreme)))
</code></pre>
<p>When an impact splatters it will only take a fraction of the velocity, otherwise know as being an inelastic rather than elastic collision. We can define a constant that will be used to reduce the total velocity of the bounced vector to reflect this elasticity.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> splatter-dampening-constant </span><span class="fl">0.7</span>)

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> splatter-vector </span>[velocity]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [bounced-vector (bounce-vector velocity canvas-normal)]
    (vector-multiply-by-constant bounced-vector
                                 splatter-dampening-constant)))




</code></pre>
<h2 id="paths-vs-points">Paths vs Points</h2>
<p>All of the gestures Pollock makes are fluid paths, even if the velocity along the path might be rather erratic. We now need to work out how to generate a path of points that we can then use the code we have written above to project and splatter.</p>
<p>A <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bezier curve</a> is a commonly used curve for generating a smooth curve that can be scaled indefinitely allowing us to have as many points along our path as we care to calculate.</p>
<p>Bezier curves are defined by an list of control points, so we need to be able to generate a potential unbounded list of random control points that should give use limitless different paths to paint with.</p>
<p>In order to generate a list of control points we will need to be able to:</p>
<ul>
<li>get a random number between two points for distance and steps,</li>
<li>get a random unit vector for the initial direction of the generation,</li>
<li>add vectors together to move between our control points.</li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> random-between </span>[lower-bound upper-bound]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> lower-bound (<a href="http://clojuredocs.org/clojure_core/clojure.core/rand" target="_blank" class="kw">rand</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> upper-bound lower-bound))))</code></pre>
<p>Below is an algorithm that will give well distributed random unit vectors. It was ported from code found <a href="http://www.gamedev.net/topic/499972-generate-a-random-unit-vector/#entry4261773">in GameDev the forums</a>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> random-unit-vector </span>[]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [asimuth (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/rand" target="_blank" class="kw">rand</a>) <span class="dv">2</span> Math/PI)
        k (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/rand" target="_blank" class="kw">rand</a> <span class="dv">2</span>) <span class="dv">1</span>)
        a (Math/sqrt (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> <span class="dv">1</span> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> k k)))
        i (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> (Math/cos asimuth) a)
        j (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> (Math/sin asimuth) a)]
    [i j k]))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> vector-add </span>[vector1 vector2]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> vector1 vector2))</code></pre>
<p>Now that we have a random direction in which to move we need to generate an unbounded path that will move in that direction, but randomise the position of each point within provided bounds.</p>
<p>Firstly, we can define a function that will generate a random vector inside of lower and upper bounds that can be combined with the non-randomised position to provide a randomised path.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> random-vector-between </span>[lower upper]
  [(random-between lower upper)
   (random-between lower upper)
   (random-between lower upper)])</code></pre>
<p>In order to provide an unbounded path we can use a lazy sequence. This function returns a value that is somewhat akin to list that never ends. Every time you try to look at the next value in the list it will generate one just in time for you to see no end.</p>
<p>In this function the first value returned should always be the initial starting position, each following value should be a step along the path. You can see this below, it returns the position argument cons'd with another iteration of random-path with the position randomised.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> random-path </span>[position step-vector bounds]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/cons" target="_blank" class="kw">cons</a> position
        (<a href="http://clojuredocs.org/clojure_core/clojure.core/lazy-seq" target="_blank" class="kw">lazy-seq</a> (random-path (vector-add (vector-add position step-vector)
                                           (random-vector-between (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> <span class="dv">0</span> bounds) bounds))
                               step-vector bounds))))</code></pre>
<p>We can now use this random-path lazy sequence to generate a list of control points given an initial starting point and some bounding variables. The distance, step and variation allow us to request long winding paths or short flicks.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> control-points </span>[position min-distance max-distance min-steps max-steps variation]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [direction       (random-unit-vector)
        distance        (random-between min-distance max-distance)
        steps           (random-between min-steps max-steps)
        step-vector     (vector-multiply-by-constant direction (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> distance steps))
        random-positions (<a href="http://clojuredocs.org/clojure_core/clojure.core/take" target="_blank" class="kw">take</a> steps (random-path position step-vector variation))
        end-position    (vector-add position
                                    (vector-multiply-by-constant step-vector steps))]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/conj" target="_blank" class="kw">conj</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/vec" target="_blank" class="kw">vec</a> random-positions) end-position)))
</code></pre>
<p>In order to turn this list of control points into a list of points that represent a path we need an algorithm. The most commonly used is a recursive algorithm proved by De Casteljau. There is a <a href="https://www.youtube.com/watch?v=YATikPP2q70">great video on YouTube</a> explaining this algorithm that I recommend you watch.</p>
<p>At the core of the algorithm is an equation that will return a point along a line weighted by a variable, <span class="math">\(t\)</span> which dictates how close it is to each end of the line:</p>
<p><span class="math">\(P = (1 - t)P_{0} + tP_{1}\)</span></p>
<p>For example, if a line runs from <span class="math">\(P_{0}\)</span> to <span class="math">\(P_{1}\)</span> and <span class="math">\(t\)</span> is 0 then the outputted point with be equal to <span class="math">\(P_{0}\)</span> and if it is 1 then <span class="math">\(P_{1}\)</span>.</p>
<p>De Casteljau's algorithm recursively creates a new set of points by using the above equation for a fixed <span class="math">\(t\)</span> against all the lines created by the control points. It does this until there is just a single point, this is a point on the bezier curve. It <span class="math">\(t\)</span> from 0 to 1 and for each step gets a point along the curve.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> recur-relation </span>[t a b]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> t b) (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> a (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> <span class="dv">1</span> t))))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> for-component </span>[t component-vals]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/=" target="_blank" class="kw">=</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/count" target="_blank" class="kw">count</a> component-vals) <span class="dv">1</span>)
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/first" target="_blank" class="kw">first</a> component-vals)
    (for-component t
      (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(recur-relation t %<span class="dv">1</span> %<span class="dv">2</span>) component-vals (<a href="http://clojuredocs.org/clojure_core/clojure.core/rest" target="_blank" class="kw">rest</a> component-vals)))))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> for-t </span>[t components]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(for-component t %) components))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> de-casteljau </span>[control-points step-amount]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [x-vals (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/first" target="_blank" class="kw">first</a> control-points)
        y-vals (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/second" target="_blank" class="kw">second</a> control-points)
        z-vals (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(<a href="http://clojuredocs.org/clojure_core/clojure.core/nth" target="_blank" class="kw">nth</a> % <span class="dv">2</span>) control-points)
        points (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(for-t % [x-vals y-vals z-vals]) (<a href="http://clojuredocs.org/clojure_core/clojure.core/range" target="_blank" class="kw">range</a> <span class="dv">0</span> <span class="dv">1</span> step-amount))]
    points))</code></pre>
<p>This can generate paths that go below the canvas, we should set these to 0 as it is the equivalent of painting on the canvas</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> ensure-above-canvas </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [[i j k]] [i (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/&lt;" target="_blank" class="kw">&lt;</a> j <span class="dv">0</span>) <span class="dv">0</span> j) k]) <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>))





</code></pre>
<h2 id="motion-going-through-the-paces">Motion, going through the paces</h2>
<p>All the points along the generated path should have an associated velocity. To start with we can generate a linear velocity along the path, given a randomised total time to traverse the path and the total length of the path.</p>
<p>In order to calculate the length of the paths, we will want to do something similar to a map but with pairs of values. Using this we can take two points, calculate the distance between them and then sum all the distances</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> map-2 </span>[f coll]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/when-let" target="_blank" class="kw">when-let</a> [s (<a href="http://clojuredocs.org/clojure_core/clojure.core/seq" target="_blank" class="kw">seq</a> coll)]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [s1 (<a href="http://clojuredocs.org/clojure_core/clojure.core/first" target="_blank" class="kw">first</a> s)
          s2 (<a href="http://clojuredocs.org/clojure_core/clojure.core/second" target="_blank" class="kw">second</a> s)]
      (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/not" target="_blank" class="kw">not</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/nil?" target="_blank" class="kw">nil?</a> s2))
        (<a href="http://clojuredocs.org/clojure_core/clojure.core/cons" target="_blank" class="kw">cons</a> (f (<a href="http://clojuredocs.org/clojure_core/clojure.core/first" target="_blank" class="kw">first</a> s) (<a href="http://clojuredocs.org/clojure_core/clojure.core/second" target="_blank" class="kw">second</a> s)) (map<span class="dv">-2</span> f (<a href="http://clojuredocs.org/clojure_core/clojure.core/rest" target="_blank" class="kw">rest</a> s)))))))</code></pre>
<p>in order to find the distance between two points we need subtract the two vectors, square and sum the resultant dimensions and then take the root. (https://en.wikipedia.org/wiki/Euclidean_distance)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> vector-multiply </span>[vector1 vector2]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> vector1 vector2))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> distance-between-points </span>[point1 point2]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [difference-vector (vector-subtraction point1 point2)
        summed-vector (<a href="http://clojuredocs.org/clojure_core/clojure.core/reduce" target="_blank" class="kw">reduce</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (vector-multiply difference-vector difference-vector))]
    (Math/sqrt summed-vector)))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> path-length </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/reduce" target="_blank" class="kw">reduce</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/+" target="_blank" class="kw">+</a> (map<span class="dv">-2</span> distance-between-points <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)))


(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> vector-divide-by-const </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a> const]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> % const) <a href="http://clojuredocs.org/clojure_core/clojure.core/vector" target="_blank" class="kw">vector</a>))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> velocity-between </span>[point1 point2 total-time total-distance]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [difference-vector (vector-subtraction point1 point2)
        time-between (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> total-time (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> (distance-between-points point1 point2)
                                      total-distance))]
    (vector-divide-by-const difference-vector time-between)))</code></pre>
<p>This calculation will leave off the last points velocity, we can just set it to 0</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> path-velocities </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a> total-time]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [total-distance   (path-length <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)
        number-of-points (<a href="http://clojuredocs.org/clojure_core/clojure.core/count" target="_blank" class="kw">count</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/conj" target="_blank" class="kw">conj</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/vec" target="_blank" class="kw">vec</a> (map<span class="dv">-2</span> #(velocity-between %<span class="dv">1</span> %<span class="dv">2</span>
                                         total-time
                                         total-distance)
                      <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>))
          [<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>])))</code></pre>
<p>As well as the velocity at each point along the path, we also need how much paint there is falling. Again to keep life simple we are going to model this as a linear flow along the path with there always being no paint left.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> path-masses </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a> initial-mass]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [number-of-points (<a href="http://clojuredocs.org/clojure_core/clojure.core/count" target="_blank" class="kw">count</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)
        step (<a href="http://clojuredocs.org/clojure_core/clojure.core/-" target="_blank" class="kw">-</a> <span class="dv">0</span> (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> initial-mass number-of-points))]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/take" target="_blank" class="kw">take</a> number-of-points (<a href="http://clojuredocs.org/clojure_core/clojure.core/range" target="_blank" class="kw">range</a> initial-mass <span class="dv">0</span> step))))




</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>I've pulled a bunch of colours that Pollock used in his seminal work &quot;Number 8&quot; so that each flick of paint can be rendered in a random colour out of this palette</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> canvas-colour </span>[<span class="dv">142</span> <span class="dv">141</span> <span class="dv">93</span>])

(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> paint-colours</span>
  [[<span class="dv">232</span> <span class="dv">51</span> <span class="dv">1</span>]
   [<span class="dv">248</span> <span class="dv">179</span> <span class="dv">10</span>]
   [<span class="dv">247</span> <span class="dv">239</span> <span class="dv">189</span>]
   [<span class="dv">29</span> <span class="dv">16</span> <span class="dv">8</span>]])

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> pick-a-colour </span>[]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/nth" target="_blank" class="kw">nth</a> paint-colours (<a href="http://clojuredocs.org/clojure_core/clojure.core/rand-int" target="_blank" class="kw">rand-int</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/count" target="_blank" class="kw">count</a> paint-colours))))</code></pre>
<p>Now we need to assemble all of the above functions into something the resembles Jackson Pollock applying paint to a canvas. We start with a point, project a path, work out masses and velocities, project and then splatter. This is all then packaged up with a colour for drawing onto our canvas.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> fling-paint </span>[]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [position       (starting-point)
        total-time     (random-between <span class="dv">1</span> <span class="dv">5</span>)
        <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>           (ensure-above-canvas (de-casteljau (control-points position <span class="fl">0.1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">15</span> <span class="fl">0.4</span>) <span class="fl">0.01</span>))
        velocities     (path-velocities <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a> total-time)
        masses         (path-masses <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a> (random-between <span class="fl">0.1</span> <span class="dv">1</span>))
        projected-path (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(project-point %<span class="dv">1</span> %<span class="dv">2</span>) <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a> velocities)
        splatter       (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [[position velocity] mass]
                              (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (does-impact-splatter? mass velocity)
                                [position (splatter-vector velocity) (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> mass splatter-dampening-constant)]
                                nil))
                            projected-path masses)
        projected-splatter (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [[position velocity mass <a href="http://clojuredocs.org/clojure_core/clojure.core/:as" target="_blank" class="kw">:as</a> point]]
                                  (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/nil?" target="_blank" class="kw">nil?</a> point)
                                    nil
                                    (<a href="http://clojuredocs.org/clojure_core/clojure.core/conj" target="_blank" class="kw">conj</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/vec" target="_blank" class="kw">vec</a> (project-point position velocity)) mass)))
                                splatter)]
    {<a href="http://clojuredocs.org/clojure_core/clojure.core/:colour" target="_blank" class="kw">:colour</a> (pick-a-colour)
     <a href="http://clojuredocs.org/clojure_core/clojure.core/:air-path" target="_blank" class="kw">:air-path</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>
     <a href="http://clojuredocs.org/clojure_core/clojure.core/:canvas-path" target="_blank" class="kw">:canvas-path</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> #(<a href="http://clojuredocs.org/clojure_core/clojure.core/conj" target="_blank" class="kw">conj</a> %<span class="dv">1</span> %<span class="dv">2</span>) projected-path masses)
     <a href="http://clojuredocs.org/clojure_core/clojure.core/:splatter" target="_blank" class="kw">:splatter</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/filter" target="_blank" class="kw">filter</a> #(<a href="http://clojuredocs.org/clojure_core/clojure.core/not-any?" target="_blank" class="kw">not-any?</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/nil?" target="_blank" class="kw">nil?</a> %) (partition-by <a href="http://clojuredocs.org/clojure_core/clojure.core/nil?" target="_blank" class="kw">nil?</a> projected-splatter))}))




</code></pre>
<h2 id="rendering-the-canvas">Rendering the canvas</h2>
<p>We need to know the available size for the outputted image to fit in. To work this out we are going to have to interface with JavaScript directly. Luckily ClojureScript makes this very easy using the <code>js</code> namespace.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> image-width </span>(.-clientWidth (.querySelector js/document <span class="st">&quot;#pollock&quot;</span>)))</code></pre>
<p>Now we have the width of the image we can use the dimensions of the space to work out the pixel size of the image and how to convert between metres and pixels.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> pixels-in-a-metre</span>
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [[width _ _] space]
    (<a href="http://clojuredocs.org/clojure_core/clojure.core//" target="_blank" class="kw">/</a> image-width width)))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> metres-to-pixels </span>[metres]
  (Math/floor (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> metres pixels-in-a-metre)))</code></pre>
<p>We can now use this function to work out the size the sketch should be and how to convert a position in metres over to a position to be drawn in the image.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> sketch-size</span>
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [[width _ height] space]
    [(metres-to-pixels width)
     (metres-to-pixels height)]))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> position-to-pixel </span>[[i j k]]
  [(metres-to-pixels i)
   (metres-to-pixels k)])
</code></pre>
<p>Now the dimensions of the image our calculated we can use Quil to define the sketch that we will draw into. We also need to define a function that will initialise the image into the state we want it. This function will be run when the sketch is defined.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> setup-image </span>[]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/apply" target="_blank" class="kw">apply</a> q/background canvas-colour)
  (q/fill <span class="dv">0</span>))

(q/defsketch pollock
  <a href="http://clojuredocs.org/clojure_core/clojure.core/:setup" target="_blank" class="kw">:setup</a> setup-image
  <a href="http://clojuredocs.org/clojure_core/clojure.core/:host" target="_blank" class="kw">:host</a> <span class="st">&quot;pollock&quot;</span>     <span class="co">;; the id of the &lt;canvas&gt; element</span>
  <a href="http://clojuredocs.org/clojure_core/clojure.core/:size" target="_blank" class="kw">:size</a> sketch-size)</code></pre>
<p>To draw the trails of paint across the canvas we need draw a path following the defined positions, which takes into account the amount of paint at each position and uses this to set with width of the path. In order to do this cleanly in Quil we need to consider the path as pairs of positions that we shall draw paths between using the initial paint amount as the stroke-weight. This allows for a smooth decrease in the width of the path.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> mass-to-weight </span>[mass]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/*" target="_blank" class="kw">*</a> <span class="dv">50</span> mass))

(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> draw-path </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/doall" target="_blank" class="kw">doall</a>
   (map<span class="dv">-2</span> (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [[position1 _ mass] [position2 _ _]]
            (q/stroke-weight (mass-to-weight mass))
            (<a href="http://clojuredocs.org/clojure_core/clojure.core/apply" target="_blank" class="kw">apply</a> q/line (<a href="http://clojuredocs.org/clojure_core/clojure.core/concat" target="_blank" class="kw">concat</a> (position-to-pixel position1) (position-to-pixel position2))))
          <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)))</code></pre>
<p>For splatter we are just going to draw a point that has a stroke-weight proportional to the amount of paint.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> draw-splats </span>[<a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>]
  (<a href="http://clojuredocs.org/clojure_core/clojure.core/doall" target="_blank" class="kw">doall</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [[position _ mass]]
                (q/stroke-weight (mass-to-weight mass))
                (<a href="http://clojuredocs.org/clojure_core/clojure.core/apply" target="_blank" class="kw">apply</a> q/point (position-to-pixel position)))
              <a href="http://clojuredocs.org/clojure_core/clojure.core/path" target="_blank" class="kw">path</a>)))</code></pre>
<p>Now that we can render the result of flinging some paint around we need a function that will fling the paint and render the result.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<a href="http://clojuredocs.org/clojure_core/clojure.core/defn" target="_blank" class="kw">defn</a><span class="fu"> fling-and-render </span>[&amp; any]
  (q/with-sketch (q/get-sketch-by-id <span class="st">&quot;pollock&quot;</span>)
    (<a href="http://clojuredocs.org/clojure_core/clojure.core/let" target="_blank" class="kw">let</a> [{<a href="http://clojuredocs.org/clojure_core/clojure.core/:keys" target="_blank" class="kw">:keys</a> [colour canvas-path splatter]} (fling-paint)]
      (q/stroke (<a href="http://clojuredocs.org/clojure_core/clojure.core/apply" target="_blank" class="kw">apply</a> q/color colour))
      (draw-path canvas-path)
      (<a href="http://clojuredocs.org/clojure_core/clojure.core/doall" target="_blank" class="kw">doall</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/map" target="_blank" class="kw">map</a> draw-splats splatter)))))
</code></pre>
<p>Lastly, we shall attach to the buttons and cause our image to come to life.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(.addEventListener (.querySelector js/document <span class="st">&quot;#add&quot;</span>)
                   <span class="st">&quot;click&quot;</span>
                   fling-and-render)

(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> interval-ref </span>(<a href="http://clojuredocs.org/clojure_core/clojure.core/atom" target="_blank" class="kw">atom</a> nil))
(<a href="http://clojuredocs.org/clojure_core/clojure.core/def" target="_blank" class="kw">def</a><span class="fu"> fill-count </span>(<a href="http://clojuredocs.org/clojure_core/clojure.core/atom" target="_blank" class="kw">atom</a> <span class="dv">0</span>))
(.addEventListener (.querySelector js/document <span class="st">&quot;#fill&quot;</span>)
                   <span class="st">&quot;click&quot;</span>
                   (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> [<a href="http://clojuredocs.org/clojure_core/clojure.core/e" target="_blank" class="kw">e</a>]
                     (<a href="http://clojuredocs.org/clojure_core/clojure.core/reset!" target="_blank" class="kw">reset!</a> interval-ref
                             (js/setInterval (<a href="http://clojuredocs.org/clojure_core/clojure.core/fn" target="_blank" class="kw">fn</a> []
                                               (<a href="http://clojuredocs.org/clojure_core/clojure.core/if" target="_blank" class="kw">if</a> (<a href="http://clojuredocs.org/clojure_core/clojure.core/&gt;" target="_blank" class="kw">&gt;</a> <a href="http://clojuredocs.org/clojure_core/clojure.core/@fill-count" target="_blank" class="kw">@fill-count</a> <span class="dv">500</span>)
                                                 (js/clearInterval <a href="http://clojuredocs.org/clojure_core/clojure.core/@interval-ref)" target="_blank" class="kw">@interval-ref)</a>
                                                 (<a href="http://clojuredocs.org/clojure_core/clojure.core/do" target="_blank" class="kw">do</a> (fling-and-render) (<a href="http://clojuredocs.org/clojure_core/clojure.core/swap!" target="_blank" class="kw">swap!</a> fill-count <a href="http://clojuredocs.org/clojure_core/clojure.core/inc" target="_blank" class="kw">inc</a>)))) <span class="dv">100</span>))))</code></pre>
    </main>
    <footer>
      Written with <abbr class="heart" title="love">&#9829;</abbr> by <a href="/">Tom Booth</a>
    </footer>
    <script src="js/processing-1.4.8.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/main.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-37313472-4', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
